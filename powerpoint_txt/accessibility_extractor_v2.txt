"""
PowerPoint Reading Order Extractor V2 - Production Ready
Extracts shapes in PowerPoint slides in proper reading order with semantic roles.
Includes configurable logging for debugging without production noise.
"""

from pptx import Presentation
from pptx.enum.shapes import MSO_SHAPE_TYPE
import xml.etree.ElementTree as ET
import logging


class AccessibilityOrderExtractorV2:
    """
    Extracts shapes from PowerPoint slides in proper reading order with semantic roles.

    Args:
        use_accessibility_order: If True, uses semantic XML-based ordering. If False, uses basic recursive expansion.
        debug_level: Logging verbosity - 'DEBUG', 'INFO', 'WARNING', 'ERROR'. Default 'WARNING'.
        log_file: Optional path to write logs to file alongside console output.
    """

    def __init__(self, use_accessibility_order=True, debug_level='WARNING', log_file=None):
        self.accessibility_order = use_accessibility_order
        self.use_accessibility_order = use_accessibility_order  # Backward compatibility
        self.last_extraction_method = "not_extracted"

        # XML namespaces for PowerPoint OOXML processing
        self.namespaces = {
            'p': 'http://schemas.openxmlformats.org/presentationml/2006/main',
            'a': 'http://schemas.openxmlformats.org/drawingml/2006/main',
            'r': 'http://schemas.openxmlformats.org/officeDocument/2006/relationships'
        }

        # Store shape classifications for later retrieval
        self.shape_classifications = {}

        # Configure logger
        self.logger = logging.getLogger(__name__)
        self.logger.setLevel(getattr(logging, debug_level.upper()))

        # Add console handler if none exists
        if not self.logger.handlers:
            console_handler = logging.StreamHandler()
            console_formatter = logging.Formatter('%(levelname)s: %(message)s')
            console_handler.setFormatter(console_formatter)
            self.logger.addHandler(console_handler)

        # Add file handler if requested
        if log_file:
            file_handler = logging.FileHandler(log_file)
            file_formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')
            file_handler.setFormatter(file_formatter)
            self.logger.addHandler(file_handler)

    def get_slide_reading_order(self, slide, slide_number):
        """
        Main method to get reading order for a slide with proper role assignment.

        Returns:
            List of (shape, role) tuples in reading order
        """
        self.logger.debug(f"ğŸ¯ === SLIDE {slide_number} READING ORDER ANALYSIS ===")

        original_shapes = list(slide.shapes)
        self.logger.debug(f"ğŸ“Š Original slide had {len(original_shapes)} shapes")

        # Use the semantic accessibility order method
        if self.accessibility_order:
            self.logger.info(f"Using semantic accessibility order for slide {slide_number}")
            final_shapes = self._get_semantic_accessibility_order(slide)
            self.last_extraction_method = "semantic_accessibility_order"
        else:
            self.logger.info(f"Using recursive group expansion for slide {slide_number}")
            final_shapes = self._expand_all_groups_recursively(original_shapes)
            self.last_extraction_method = "recursive_group_expansion"

        self.logger.debug(f"âœ… Final processing yielded {len(final_shapes)} shapes")

        # Create (shape, role) tuples as expected by the pipeline
        shapes_with_roles = []
        for i, shape in enumerate(final_shapes):
            # Use the classification stored in _get_semantic_accessibility_order
            if hasattr(self, 'shape_classifications') and id(shape) in self.shape_classifications:
                semantic_role = self.shape_classifications[id(shape)]
            else:
                # Fallback to XML-based role detection if classification wasn't stored
                semantic_role = self._get_semantic_role_from_xml(shape)

            shapes_with_roles.append((shape, semantic_role))

            # Enhanced debug info
            shape_type = str(shape.shape_type).split('.')[-1] if shape.shape_type else "None"
            shape_name = getattr(shape, 'name', 'unnamed')
            text_preview = ""

            try:
                if hasattr(shape, 'text') and shape.text:
                    text_preview = shape.text.strip()[:50] + "..." if len(
                        shape.text.strip()) > 50 else shape.text.strip()
            except:
                text_preview = "[No accessible text]"

            self.logger.debug(
                f"  {i + 1:2d}. {shape_type:12} | Role: {semantic_role:8} | Name: {shape_name:15} | Text: '{text_preview}'")

        return shapes_with_roles

    def _get_semantic_accessibility_order(self, slide):
        """
        Enhanced semantic ordering with comprehensive debugging and duplicate elimination.
        """
        self.logger.debug(f"ğŸ”¬ === DETAILED SEMANTIC ACCESSIBILITY ORDER DEBUG ===")
        debug_step = 1

        # Step 1: Get all shapes in XML document order (deduplicated)
        self.logger.debug(f"ğŸ“‹ Step {debug_step}: Getting XML document order")
        debug_step += 1

        xml_ordered_shapes = self._get_xml_document_order_deduplicated(slide)
        self.logger.debug(f"   âœ“ XML document order returned {len(xml_ordered_shapes)} shapes (after deduplication)")

        # Debug: Show what we got from XML parsing
        self.logger.debug(f"   ğŸ“ Shape breakdown from XML:")
        shape_type_counts = {}
        for shape in xml_ordered_shapes:
            shape_type = str(shape.shape_type).split('.')[-1] if shape.shape_type else "None"
            shape_type_counts[shape_type] = shape_type_counts.get(shape_type, 0) + 1

        for shape_type, count in sorted(shape_type_counts.items()):
            self.logger.debug(f"      â€¢ {shape_type}: {count}")

        # Step 2: Check for duplicates before processing
        self.logger.debug(f"ğŸ” Step {debug_step}: Checking for duplicates in XML order")
        debug_step += 1

        shape_ids = [id(shape) for shape in xml_ordered_shapes]
        unique_ids = set(shape_ids)

        if len(shape_ids) != len(unique_ids):
            duplicate_count = len(shape_ids) - len(unique_ids)
            self.logger.warning(f"Found {duplicate_count} duplicate objects after XML parsing")

            # Show which shapes are duplicated
            id_counts = {}
            for shape_id in shape_ids:
                id_counts[shape_id] = id_counts.get(shape_id, 0) + 1

            duplicates = {k: v for k, v in id_counts.items() if v > 1}
            self.logger.debug(f"   ğŸ“Š Duplicate analysis: {len(duplicates)} unique objects appear multiple times")
        else:
            self.logger.debug(f"   âœ… No duplicates found in XML order")

        # Step 3: Process groups by recursively extracting all children
        self.logger.debug(f"âš™ï¸  Step {debug_step}: Processing groups and expanding children")
        debug_step += 1

        final_ordered_shapes = []
        group_count = 0
        expanded_children_count = 0
        non_group_count = 0

        for i, shape in enumerate(xml_ordered_shapes):
            shape_type = str(shape.shape_type).split('.')[-1] if shape.shape_type else "None"
            shape_name = getattr(shape, 'name', 'unnamed')

            if shape.shape_type == MSO_SHAPE_TYPE.GROUP:
                group_count += 1
                self.logger.debug(f"   ğŸ·ï¸  Found group {group_count} (#{i + 1}): '{shape_name}' (type: {shape_type})")

                # Use recursive expansion for groups
                group_children = self._expand_all_groups_recursively([shape])
                self.logger.debug(f"      ğŸ“¦ Group recursively expanded to {len(group_children)} children")

                # Show what's inside the group
                if group_children:
                    self.logger.debug(f"      ğŸ“‹ Group contents:")
                    for j, child in enumerate(group_children):
                        child_type = str(child.shape_type).split('.')[-1] if child.shape_type else "None"
                        child_name = getattr(child, 'name', 'unnamed')
                        child_text = ""
                        try:
                            if hasattr(child, 'text') and child.text:
                                child_text = child.text.strip()[:30] + "..." if len(
                                    child.text.strip()) > 30 else child.text.strip()
                        except:
                            pass
                        self.logger.debug(f"         {j + 1}. {child_type} '{child_name}' - '{child_text}'")

                final_ordered_shapes.extend(group_children)
                expanded_children_count += len(group_children)
            else:
                non_group_count += 1
                self.logger.debug(f"   ğŸ“„ Non-group shape #{i + 1}: '{shape_name}' (type: {shape_type})")
                final_ordered_shapes.append(shape)

        self.logger.debug(f"   ğŸ“Š Group processing summary:")
        self.logger.debug(f"      â€¢ Groups found: {group_count}")
        self.logger.debug(f"      â€¢ Non-group shapes: {non_group_count}")
        self.logger.debug(f"      â€¢ Children expanded from groups: {expanded_children_count}")
        self.logger.debug(f"      â€¢ Total shapes after expansion: {len(final_ordered_shapes)}")

        # Step 4: Final deduplication by object ID
        self.logger.debug(f"ğŸ§¹ Step {debug_step}: Final deduplication by object ID")
        debug_step += 1

        shapes_before_dedup = len(final_ordered_shapes)
        deduplicated_shapes = self._deduplicate_shapes_by_object_id(final_ordered_shapes)
        shapes_after_dedup = len(deduplicated_shapes)

        self.logger.debug(f"   ğŸ“Š Deduplication results:")
        self.logger.debug(f"      â€¢ Before: {shapes_before_dedup} shapes")
        self.logger.debug(f"      â€¢ After: {shapes_after_dedup} shapes")
        self.logger.debug(f"      â€¢ Removed: {shapes_before_dedup - shapes_after_dedup} duplicates")

        # Step 5: Separate by semantic importance for final ordering
        self.logger.debug(f"ğŸ·ï¸  Step {debug_step}: Semantic classification")
        debug_step += 1

        title_shapes = []
        slide_number_shapes = []
        content_shapes = []
        other_shapes = []
        shape_classifications = {}

        for i, shape in enumerate(deduplicated_shapes):
            shape_type = str(shape.shape_type).split('.')[-1] if shape.shape_type else "None"
            shape_name = getattr(shape, 'name', 'unnamed')

            # Get text preview for classification debugging
            text_preview = ""
            try:
                if hasattr(shape, 'text') and shape.text:
                    text_preview = shape.text.strip()[:40] + "..." if len(
                        shape.text.strip()) > 40 else shape.text.strip()
            except:
                text_preview = "[No accessible text]"

            # Direct classification logic
            if "title" in shape_name.lower() and "subtitle" not in shape_name.lower():
                title_shapes.append(shape)
                role = "title"
            elif "slide number" in shape_name.lower():
                slide_number_shapes.append(shape)
                role = "slide_number"
            elif text_preview and text_preview.strip():
                content_shapes.append(shape)
                role = "content"
            else:
                other_shapes.append(shape)
                role = "other"

            # Store the classification for later use
            shape_classifications[id(shape)] = role
            self.logger.debug(
                f"   {i + 1:2d}. {shape_type:12} | Role: {role:12} | '{shape_name}' | Text: '{text_preview}'")

        self.logger.debug(f"   ğŸ“Š Semantic classification summary:")
        self.logger.debug(f"      â€¢ Title shapes: {len(title_shapes)}")
        self.logger.debug(f"      â€¢ Slide number shapes: {len(slide_number_shapes)}")
        self.logger.debug(f"      â€¢ Content shapes: {len(content_shapes)}")
        self.logger.debug(f"      â€¢ Other shapes: {len(other_shapes)}")

        # Step 6: Return in semantic priority order
        self.logger.info(
            f"Final semantic ordering complete: {len(title_shapes)} titles, {len(content_shapes)} content, {len(other_shapes)} other")
        result = title_shapes + content_shapes + other_shapes
        self.logger.debug(f"   ğŸ“‹ Final semantic order contains {len(result)} shapes")
        self.logger.debug(f"   ğŸ¯ Order: Titles â†’ Content â†’ Other")

        # Store classifications for use in final output
        self.shape_classifications = shape_classifications

        return result

    def _expand_all_groups_recursively(self, shapes, depth=0):
        """
        Recursively expand all groups to extract individual shapes.
        """
        indent = "  " * depth
        expanded_shapes = []

        for shape in shapes:
            if shape.shape_type == MSO_SHAPE_TYPE.GROUP:
                group_name = getattr(shape, 'name', 'unnamed')
                self.logger.debug(f"{indent}ğŸ”„ Expanding group at depth {depth}: '{group_name}'")

                group_children = list(shape.shapes)
                self.logger.debug(f"{indent}   ğŸ“¦ Group has {len(group_children)} direct children")

                # Recursively expand any nested groups within these children
                recursively_expanded = self._expand_all_groups_recursively(group_children, depth + 1)
                expanded_shapes.extend(recursively_expanded)

                self.logger.debug(
                    f"{indent}   âœ… Group expansion at depth {depth} yielded {len(recursively_expanded)} final shapes")
            else:
                # It's not a group, so add it directly
                expanded_shapes.append(shape)

        return expanded_shapes

    def _get_semantic_role_from_xml(self, shape):
        """
        Determine semantic role of a shape based on name and content.
        """
        try:
            shape_name = getattr(shape, 'name', '').lower()

            # Check shape name first (most reliable)
            if "title" in shape_name and "subtitle" not in shape_name:
                return "title"
            elif "subtitle" in shape_name or "sub-title" in shape_name:
                return "subtitle"
            elif "slide number" in shape_name:
                return "slide_number"

            # Check text content for additional clues
            if hasattr(shape, 'text') and shape.text:
                text = shape.text.lower().strip()

                # More sophisticated role detection based on text
                if len(text) < 100 and any(keyword in text for keyword in ['title', 'heading', 'header']):
                    return "title"
                elif any(keyword in text for keyword in ['subtitle', 'subheading', 'sub-title']):
                    return "subtitle"
                elif len(text) > 10:  # Substantial text content
                    return "content"
                else:
                    return "other"

            # Check if it's a visual element without text
            if hasattr(shape, 'shape_type'):
                if shape.shape_type in [MSO_SHAPE_TYPE.PICTURE, MSO_SHAPE_TYPE.CHART]:
                    return "content"
                elif shape.shape_type == MSO_SHAPE_TYPE.TABLE:
                    return "content"

            return "other"

        except Exception as e:
            self.logger.warning(f"Error determining semantic role: {e}")
            return "other"

    def _get_xml_document_order_deduplicated(self, slide):
        """
        Get shapes in actual XML document order with deduplication.
        Parses the underlying XML to get the true document order.
        """
        try:
            self.logger.debug(f"   ğŸ” Parsing XML to get true document order...")

            # Get the slide's XML element
            slide_element = slide._element

            # Find the shape tree (spTree) which contains all shapes
            ns = {'p': 'http://schemas.openxmlformats.org/presentationml/2006/main'}
            shape_tree = slide_element.find('.//p:spTree', ns)

            if shape_tree is None:
                self.logger.warning(f"No shape tree found, falling back to slide.shapes")
                return self._deduplicate_shapes_by_object_id(list(slide.shapes))

            # Get all shape elements in XML document order
            shape_elements = []
            for child in shape_tree:
                # Only include actual shape elements, skip layout elements
                if child.tag.endswith('}sp') or child.tag.endswith('}grpSp') or child.tag.endswith(
                        '}pic') or child.tag.endswith('}cxnSp'):
                    shape_elements.append(child)

            self.logger.debug(f"   ğŸ“‹ Found {len(shape_elements)} shape elements in XML")

            # Create a mapping from XML elements to python-pptx shape objects
            xml_to_shape_map = {}

            # Build the mapping by comparing XML elements
            for shape in slide.shapes:
                shape_xml = shape._element
                for xml_elem in shape_elements:
                    if shape_xml is xml_elem:
                        xml_to_shape_map[xml_elem] = shape
                        break

            # Build the ordered list based on XML document order
            ordered_shapes = []
            for xml_elem in shape_elements:
                if xml_elem in xml_to_shape_map:
                    ordered_shapes.append(xml_to_shape_map[xml_elem])
                else:
                    self.logger.warning(f"XML element not matched to shape object")

            self.logger.debug(f"   âœ… Successfully mapped {len(ordered_shapes)} shapes from XML order")

            # Deduplicate and return
            return self._deduplicate_shapes_by_object_id(ordered_shapes)

        except Exception as e:
            self.logger.warning(f"Error parsing XML document order: {e}")
            self.logger.info(f"Falling back to slide.shapes order")
            return self._deduplicate_shapes_by_object_id(list(slide.shapes))

    def _deduplicate_shapes_by_object_id(self, shapes):
        """
        Remove duplicate shapes based on object ID.
        """
        seen_ids = set()
        deduplicated = []
        duplicates_found = 0

        for shape in shapes:
            shape_id = id(shape)
            if shape_id not in seen_ids:
                seen_ids.add(shape_id)
                deduplicated.append(shape)
            else:
                duplicates_found += 1

        if duplicates_found > 0:
            self.logger.warning(f"Removed {duplicates_found} duplicate shape references")

        return deduplicated

    # Pipeline integration methods

    def get_reading_order_of_grouped_shapes(self, group_shape):
        """
        Get reading order for shapes within a group.
        Required by ContentExtractor for processing group children.
        """
        try:
            shapes = list(group_shape.shapes)
            self.logger.debug(f"Group '{getattr(group_shape, 'name', 'unnamed')}' has {len(shapes)} children")
            return shapes
        except Exception as e:
            self.logger.error(f"Error getting group shapes: {e}")
            return []

    def get_reading_order_of_grouped_by_shape(self, shape):
        """
        Alias for backward compatibility.
        """
        return self.get_reading_order_of_grouped_shapes(shape)

    def get_last_extraction_method(self):
        """
        Return the last extraction method used.
        Required by PowerPointProcessor for debugging and metadata.
        """
        return self.last_extraction_method

    def _has_xml_access(self, slide):
        """
        Check if XML access is available for the slide.
        Required by PowerPointProcessor for determining processing strategy.
        """
        try:
            return len(slide.shapes) >= 0
        except:
            return False

    # Backward compatibility property
    @property
    def use_accessibility_order(self):
        """Backward compatibility property."""
        return self.accessibility_order

    @use_accessibility_order.setter
    def use_accessibility_order(self, value):
        """Backward compatibility property setter."""
        self.accessibility_order = value


def test_powerpoint_reading_order(file_path, debug_level='WARNING'):
    """
    Test the reading order extractor on a PowerPoint file.

    Args:
        file_path: Path to PowerPoint file
        debug_level: Logging level - 'DEBUG', 'INFO', 'WARNING', 'ERROR'
    """
    print(f"ğŸ” Testing PowerPoint reading order extraction on: {file_path}")
    print("=" * 80)

    try:
        # Load the PowerPoint presentation
        prs = Presentation(file_path)
        print(f"âœ… Successfully loaded presentation with {len(prs.slides)} slides")

        # Initialize the extractor
        extractor = AccessibilityOrderExtractorV2(
            use_accessibility_order=True,
            debug_level=debug_level
        )

        # Process each slide
        for slide_num, slide in enumerate(prs.slides, 1):
            print(f"\nğŸ¬ === PROCESSING SLIDE {slide_num} ===")
            print("=" * 60)

            # Test the main reading order method
            shapes_with_roles = extractor.get_slide_reading_order(slide, slide_num)

            print(f"\nğŸ“‹ === SLIDE {slide_num} SUMMARY ===")
            print(f"   â€¢ Total shapes found: {len(shapes_with_roles)}")

            # Show detailed breakdown
            role_counts = {}
            for shape, role in shapes_with_roles:
                role_counts[role] = role_counts.get(role, 0) + 1

            for role, count in sorted(role_counts.items()):
                print(f"   â€¢ {role.title()} shapes: {count}")

            # Show first few shapes as example
            if shapes_with_roles:
                print(f"\n   ğŸ“ First few shapes in reading order:")
                for i, (shape, role) in enumerate(shapes_with_roles[:5]):
                    shape_type = str(shape.shape_type).split('.')[-1] if shape.shape_type else "None"
                    text_preview = ""
                    try:
                        if hasattr(shape, 'text') and shape.text:
                            text_preview = shape.text.strip()[:30] + "..." if len(
                                shape.text.strip()) > 30 else shape.text.strip()
                    except:
                        text_preview = "[No text]"

                    print(f"      {i + 1}. {role:8} | {shape_type:12} | '{text_preview}'")

                if len(shapes_with_roles) > 5:
                    print(f"      ... and {len(shapes_with_roles) - 5} more shapes")

            print()

        print("ğŸ‰ Test completed successfully!")

    except FileNotFoundError:
        print(f"âŒ Error: Could not find file at {file_path}")
        print("ğŸ’¡ Please check the file path is correct")
    except Exception as e:
        print(f"âŒ Error during processing: {str(e)}")
        print(f"ğŸ” Error type: {type(e).__name__}")
        import traceback
        print(f"ğŸ“‹ Full traceback:")
        traceback.print_exc()


if __name__ == "__main__":
    # Test with your PowerPoint file
    file_path = "/Users/jamestaylor/Downloads/testing_powerpoint_v9.122 (4).pptx"

    # Choose debug level: 'DEBUG' (verbose), 'INFO' (moderate), 'WARNING' (quiet), 'ERROR' (silent)
    test_powerpoint_reading_order(file_path, debug_level='INFO')